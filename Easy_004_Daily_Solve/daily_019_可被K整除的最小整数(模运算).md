--- Create Time: 2025-11-25 10:00:00
--- @Author: xcyy

# 可被 K 整除的最小整数

[1015. 可被 K 整除的最小整数](https://leetcode.cn/problems/smallest-integer-divisible-by-k/description/)

--- 题目描述 ---

给定正整数 k ，你需要找出可以被 k 整除的、仅包含数字 1 的最 小 正整数 n 的长度。

返回 n 的长度。如果不存在这样的 n ，就返回-1。

注意： n 可能不符合 64 位带符号整数。

--- 测试用例 ---

```text
示例 1：
输入：k = 1
输出：1
解释：最小的答案是 n = 1，其长度为 1。

示例 2：
输入：k = 2
输出：-1
解释：不存在可被 2 整除的正整数 n 。

示例 3：
输入：k = 3
输出：3
解释：最小的答案是 n = 111，其长度为 3。
```

--- 说明提示 ---

```text
1 <= k <= 10^5
```

--- 题目解答 ---

**Review**

> 加法和乘法的取模

如果让你计算 1234×6789 的个位数，你会如何计算？

由于只有个位数会影响到乘积的个位数，那么 4×9=36 的个位数 6 就是答案。

对于 1234+6789 的个位数，同理，4+9=13 的个位数 3 就是答案。

```
抽象成数学等式:
一般涉及到取模的题目，会用到如下两个恒等式，其中mod表示取模运算(modulo).
上面计算的是 m=10 的情况.
     (a+b) mod m=((a mod m)+(b mod m)) mod m
     (a⋅b) mod m=((a mod m)⋅(b mod m)) mod m
```

**根据这两个恒等式，我们可以在计算过程中（例如循环），对加法和乘法的结果取模，而不是在循环结束后再取模。**

---

对于能够整除 k 的整数 n, 有 n mod k = 0.
```
设x使上一次运算的结果, 则下一个 n mod k 的结果为 ( 10x + 1 ) mod k.

举例: k = 7
从小到大枚举n, 第一个能被k整除的数的长度就是答案.
n:    1 -> 11 -> 111 -> 1111 -> 11111 -> 111111
mod:  1 -> 4  -> 6   -> 5    -> 2     -> 0

举例: k = 24
mod: 1 -> 11 -> 15 -> 7 -> 23 -> 15 -> 7 -> ...
如果计算结果和前面某个数相同,由于计算规则不变,后面会无限重复下去,无法得到0.
具体解释无限重复下去的原因:
    由于计算规则是: ( 10x + 1 ) mod k, 
    其中 x 是上一次的结果, 如果x重复出现,那么后续利用x计算的结果就出现了重复.
```

```python
class Solution:
    def smallestRepunitDivByK( self, k: int ) -> int:
        x = 1 % k
        seen = set()
        while x and x not in seen:
            seen.add( x )
            x = ( 10 * x + 1 ) % k
        return -1 if x else len( seen ) + 1
```

- 思考点:
    - 为什么可以用取模后的x,继续计算下一个数的取模结果?
        - 因为取模运算满足**可传递性**, 即 (a+b) mod m = ((a mod m) + (b mod m)) mod m.
        - 所以 ( 10x + 1 ) mod k = ( ( 10 mod k ) * x + 1 ) mod k = ( 10 * ( x mod k ) + 1 ) mod k.
        - 所以, 利用上一次的取模结果, 可以计算出下一次的取模结果.
    - 为什么可以用集合seen来记录取模结果, 来判断是否无限循环?
        - 因为如果取模结果重复出现, 那么后续利用这个结果计算的取模结果就会无限循环.
- 时间复杂度: O(k)
- 空间复杂度: O(k)


