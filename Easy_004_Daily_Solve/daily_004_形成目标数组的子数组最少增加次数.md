# [1526. 形成目标数组的子数组最少增加次数](https://leetcode.cn/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/description/)

--- 题目描述 ---

给你一个整数数组 target 和一个数组 initial ，initial 数组与 target 数组有同样的维度，且一开始全部为 0 。

请你返回从 initial 得到 target 的最少操作次数，每次操作需遵循以下规则：

- 在 initial 中选择 任意 子数组，并将子数组中每个元素增加 1 。

答案保证在 32 位有符号整数以内。

--- 测试用例 ---

```text
示例 1：
输入：target = [1,2,3,2,1]
输出：3
解释：我们需要至少 3 次操作从 intial 数组得到 target 数组。
[0,0,0,0,0] 将下标为 0 到 4 的元素（包含二者）加 1 。
[1,1,1,1,1] 将下标为 1 到 3 的元素（包含二者）加 1 。
[1,2,2,2,1] 将下表为 2 的元素增加 1 。
[1,2,3,2,1] 得到了目标数组。

示例 2：
输入：target = [3,1,1,2]
输出：4
解释：(initial)[0,0,0,0] -> [1,1,1,1] -> [1,1,1,2] -> [2,1,1,2] -> [3,1,1,2] (target) 。

示例 3：
输入：target = [3,1,5,4,2]
输出：7
解释：(initial)[0,0,0,0,0] -> [1,1,1,1,1] -> [2,1,1,1,1] -> [3,1,1,1,1] 
                                  -> [3,1,2,2,2] -> [3,1,3,3,2] -> [3,1,4,4,2] -> [3,1,5,4,2] (target)。
                            
示例 4：
输入：target = [1,1,1,1]
输出：1
```

--- 提示说明 ---

```text
1 <= target.length <= 10^5
1 <= target[i] <= 10^5
```

--- 题目解答 ---

* 本题有「区间加一」操作，这非常适合用差分数组做。

定义 target 的差分数组 d 为
d[ i ] =

- i = 0: target[0]
- i > 0: target[i] - target[i - 1]

示例 2 的 target=[3,1,1,2]，差分数组为 d=[3,−2,0,1]。

由于全 0 数组的差分数组也全为 0，所以示例 2 相当于把 d0 =[0,0,0,0] 变成 d=[3,−2,0,1] 的最小操作次数。

根据差分数组原理，如果「区间加一」操作的不是 initial 的后缀，那么操作等价于修改 d0两个位置上的数，左边加一，右边减一。
如果操作的是 initial 的后缀，那么操作等价于把 d0 中的一个数单独加一。

示例 2 的一种操作方案如下：

[0,0,0,0]→[1,−1,0,0]→[2,−2,0,0]→[3,−2,0,0]→[3,−2,0,1]

为了最小化操作次数，优先修改两个位置上的数（加一减一），然后再考虑单独加一。

**注意到，无论每次操作修改的是两个数还是一个数，一定会把一个数加一。所以最小操作次数等于加一的次数，即 d 中所有正数之和。**

---

问：有没有一种可能，d=[2,2,−5]，负数绝对值之和比正数之和还大？

答：不可能。由于差分数组 d 的前缀和就是原数组 target，如果出现负数绝对值之和比正数之和还大，说明 d 的总和是负数，即
target[n−1]<0，这与本题的数据范围 target[i]>0 矛盾。

问：有没有一种可能，d=[2,−3,4]，无法使用「左边加一，右边减一」的操作从 [0,0,0] 得到 d？

答：不可能。同样地，计算 d 的前缀和，如果出现这种情况，说明前缀和中的某个数是负数，即 target[i]<0，这与本题的数据范围
target[i]>0 矛盾。

---
妙不可言
---
```python
class Solution:
    def minNumberOperations( self, target: List[ int ] ) -> int:
        # 差分数组原理
        # 区间加一操作等价于修改差分数组的两个位置
        # 左边加一，右边减一
        # 如果操作的是后缀，那么操作等价于把差分数组中的一个数单独加一
        # 最小操作次数等于加一的次数，即差分数组中所有正数之和

        n = len( target )
        ans = target[ 0 ]

        for i in range( 1, n ):
            ans += max( target[ i ] - target[ i - 1 ], 0 )
        return ans
```

**动态规划**
```python
class Solution:
    def minNumberOperations( self, target: List[ int ] ) -> int:

        # -- 动态规划 --
        # -- dp[ i ] 表示形成target[ 0: i+1 ]的最小操作数
        n = len( target )
        dp = [ 0 for _ in range( n ) ]

        dp[ 0 ] = target[ 0 ]

        for i in range( 1, n ):
            if target[ i ] > target[ i - 1 ]:
                dp[ i ] = dp[ i - 1 ] + target[ i ] - target[ i - 1 ]
            else:
                dp[ i ] = dp[ i - 1 ]

        return dp[ -1 ]
```

