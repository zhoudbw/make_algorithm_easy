--- Create Time: 2025-11-09 10:00:00
--- @Author: xcyy

# 将所有元素变为 0 的最少操作次数

[3542. 将所有元素变为 0 的最少操作次数](https://leetcode.cn/problems/minimum-operations-to-convert-all-elements-to-zero/description/)

--- 题目描述 ---

给你一个大小为 n 的 非负 整数数组 nums 。你的任务是对该数组执行若干次（可能为 0 次）操作，使得 所有 元素都变为 0。

在一次操作中，你可以选择一个子数组 [i, j]（其中 0 <= i <= j < n），将该子数组中所有 最小的非负整数 的设为 0。

返回使整个数组变为 0 所需的最少操作次数。

一个 子数组 是数组中的一段连续元素。

--- 测试用例 ---

```text
示例 1：
输入: nums = [0,2]
输出: 1
解释:
选择子数组 [1,1]（即 [2]），其中最小的非负整数是 2。将所有 2 设为 0，结果为 [0,0]。
因此，所需的最少操作次数为 1。

示例 2：
输入: nums = [3,1,2,1]
输出: 3
解释:
选择子数组 [1,3]（即 [1,2,1]），最小非负整数是 1。将所有 1 设为 0，结果为 [3,0,2,0]。
选择子数组 [2,2]（即 [2]），将 2 设为 0，结果为 [3,0,0,0]。
选择子数组 [0,0]（即 [3]），将 3 设为 0，结果为 [0,0,0,0]。
因此，最少操作次数为 3。

示例 3：
输入: nums = [1,2,1,2,1,2]
输出: 4
解释:
选择子数组 [0,5]（即 [1,2,1,2,1,2]），最小非负整数是 1。将所有 1 设为 0，结果为 [0,2,0,2,0,2]。
选择子数组 [1,1]（即 [2]），将 2 设为 0，结果为 [0,0,0,2,0,2]。
选择子数组 [3,3]（即 [2]），将 2 设为 0，结果为 [0,0,0,0,0,2]。
选择子数组 [5,5]（即 [2]），将 2 设为 0，结果为 [0,0,0,0,0,0]。
因此，最少操作次数为 4。
```

--- 说明提示 ---

```text
1 <= n == nums.length <= 10^5
0 <= nums[i] <= 105
```

--- 题目解答 ---

## 分治

1. 选取整个区间,将最小值变为0,操作次数+1 ( 如果最小值已经是0则跳过这步 )
2. 经过`1`操作后,区间内最小值会变成0, 此时整个区间被0分为多个子区间
3. 对每个子区间重复`1,2`操作,直到整个区间都变为0

---
经过上面的分析,利用分治来解决问题,实际上是就是统计必要的操作次数.

## 单调栈

从左往右遍历数组，只在「必须要操作」的时候，才把操作次数+1。

什么时候必须要操作？

示例3: nums=[1,2,1,2,1,2]，因为 2 左右两侧都有小于 2 的数，需要单独操作。

又例如 nums=[1,2,3,2,1]：

- 遍历到第二个 2 时，可以知道 3 左右两侧都有小于 3 的数，所以 3 必须要操作一次，答案加一。
  注意这不表示第一次操作的是3，而是某次操作会把3 变成 0。
- 遍历到末尾 1 时，可以知道中间的两个 2，左边有 1，右边也有 1，必须操作一次，答案加一。
  比如选择 [2,3,2] 可以把这两个 2 都变成0。
- 最后，数组中的 1 需要操作一次都变成 0。

**怎么知道「3 左右两侧都有小于 3 的数」?**
- 保证单调栈内元素从栈底到栈头是单调递增的即可;
- 这样当元素要加入栈中的时候,栈顶元素的上一个元素小于自身,新入的元素是栈顶元素的下一个元素,两者对比就能判断栈顶元素左右两侧是否都有小于自身的数.

遍历数组的同时，把遍历过的元素用栈记录：

- 如果当前元素比栈顶大（或者栈为空），那么直接入栈。
- 如果当前元素比栈顶小，那么对于栈顶来说，左边（栈顶倒数第二个数）比栈顶小，右边（当前元素）也比栈顶小，所以栈顶必须操作一次。然后弹出栈顶。
- 如果当前元素等于栈顶，可以在同一次操作中把当前元素与栈顶都变成 0，所以无需入栈。注意这保证了栈中没有重复元素。

如果当前元素比栈顶小，就弹出栈顶，我们会得到一个底小顶大的单调栈，这就保证了「对于栈顶来说，左边（栈顶倒数第二个数）比栈顶小」。

遍历结束后，因为栈是严格递增的，所以栈中每个非零数字都需要操作一次。

```python
class Solution:
    def minOperations( self, nums: List[ int ] ) -> int:

        ans = 0
        mono_stk = [ ]

        for v in nums:
            while mono_stk and v < mono_stk[ -1 ]:
                mono_stk.pop()
                ans += 1
            if not mono_stk or v > mono_stk[ -1 ]:
                # v == mono_stk[ -1 ]时,可以和栈顶元素在同一次操作中变为0
                mono_stk.append( v )

        # 从栈底到栈头单调递增,最小值出现在栈底,0不需要操作,故额外判断
        return ans + len( mono_stk ) - (mono_stk[ 0 ] == 0)
```

--- 补充题目 ---

[接雨水](https://leetcode.cn/problems/trapping-rain-water/description/)

[柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/)

详情见 `Easy_001_MonotonicStk/ms_001_conclusion.md`
