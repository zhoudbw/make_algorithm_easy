--- Create Time: 2025-11-11 10:00:00
--- @Author: xcyy

# 一和零

[474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/description/)

--- 题目描述 ---

给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

--- 测试用例 ---

```text
示例 1：
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。

示例 2：
输入：strs = ["10", "0", "1"], m = 1, n = 1
输出：2
解释：最大的子集是 {"0", "1"} ，所以答案是 2 。
```

--- 说明提示 ---

```text
1 <= strs.length <= 600
1 <= strs[i].length <= 100
strs[i] 仅由 '0' 和 '1' 组成
1 <= m, n <= 100
```

--- 题目解答 ---

#-- 题目理解 --
#-- 尽可能多的选择strs中的元素,使得选择的元素最多m个0和n个1,确定最大选取数量 --

#-- 01背包解决  只不过背包是二维的 --
#-- dp[ i ][ x ][ y ] 表示用0~i个物品装满最多x个0最多y个1的最大子集数


```python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:

        l = len( strs )
        dp = [ [ [ 0 for _ in range( n + 1 ) ]  # 最多n个1
                 for _ in range( m + 1 ) ]  # 最多m个0
               for _ in range( l ) ]  # 有l个物品

        def cal_count( _str ):
            if not _str: return 0, 0

            _zero, _one = 0, 0
            for v in _str:
                if v == '0': _zero += 1
                else: _one += 1
            return _zero, _one

        ans = 0
        zero, one = cal_count( strs[ 0 ] )
        for x in range( m + 1 ):
            for y in range( n + 1 ):
                if x >= zero and y >= one:
                    dp[ 0 ][ x ][ y ] = 1
                    ans = 1

        for i in range( 1, l ):
            zero, one = cal_count( strs[ i ] )
            for x in range( m + 1 ):
                for y in range( n + 1 ):
                    dp[ i ][ x ][ y ] = dp[ i - 1 ][ x ][ y ]
                    if x - zero >= 0 and y - one >= 0:
                        dp[ i ][ x ][ y ] = max( dp[ i - 1 ][ x - zero ][ y - one ] + 1, dp[ i - 1 ][ x ][ y ] )
                        ans = max( dp[ i ][ x ][ y ], ans )
        return ans 
```

* 上述代码可以做压缩: dp[ x ][ y ]表示装满最多x个0最多y个1的最大子集数
* 这样的话,为了能够使得当前dp递推出下一层dp,遍历顺序需要从后往前,因为下一次dp需要依据上一层dp的[x-zero][y-one]的值

```python
class Solution( object ):
    def findMaxForm( self, strs, m, n ):
        def cal_count( _str ):
            # 同上
            return 0, 0

        dp = [ [ 0 ] * (n + 1) for _ in range( m + 1 ) ]
        for i in range( len( strs ) ):
            zero, one = cal_count( strs[ i ] )
            for p in range( m, zero - 1, - 1 ):
                for q in range( n, one - 1, - 1 ):
                    dp[ p ][ q ] = max( dp[ p ][ q ], dp[ p - zero ][ q - one ] + 1 )
        return dp[ m ][ n ]
```